{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"calcite","text":"<p>Continuous and discrete wavelets, and the scattering transform, in <code>jax</code>.</p>"},{"location":"documentation/dwt/","title":"<code>dwt</code>","text":"<p>Discrete wavelet transform.</p>"},{"location":"documentation/dwt/#multilevel-transforms","title":"Multilevel Transforms","text":""},{"location":"documentation/dwt/#calcite.dwt.wavedec","title":"<code>calcite.dwt.wavedec(x, wavelets, pad_mode='symmetric', level=None)</code>","text":"<p>Compute the multilevel discrete wavelet transform (DWT).</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Array</code> <p>input array to compute DWT of</p> required <code>wavelets</code> <code>str | DiscreteWavelet | Sequence[str | DiscreteWavelet]</code> <p>wavelet(s) used to compute DWT. can be a sequence, in which case the specified wavelet is used per-axis.</p> required <code>pad_mode</code> <code>str</code> <p>padding mode used during computation. Defaults to \"symmetric\".</p> <code>'symmetric'</code> <code>level</code> <code>Optional[int]</code> <p>number of decomposition levels to compute. Defaults to None, in which case level will be automatically computed.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[Array, List[List[Array]]]</code> <p>Tuple[Array, List[List[Array]]]: tuple of approximation coefficients, followed by a list of lists of arrays. Each list of arrays in the list corresponds to the detail coefficients at that level.</p>"},{"location":"documentation/dwt/#calcite.dwt.waverec","title":"<code>calcite.dwt.waverec(approx, coeffs, wavelets, pad_mode='symmetric', recon_odd=None)</code>","text":"<p>Compute the multilevel inverse discrete wavelet transform.</p> <p>Parameters:</p> Name Type Description Default <code>approx</code> <code>Array</code> <p>approximation coefficients</p> required <code>coeffs</code> <code>List[List[Array]]</code> <p>list of detail coefficients at each level.</p> required <code>wavelets</code> <code>str | DiscreteWavelet | Sequence[str | DiscreteWavelet]</code> <p>wavelet used to compute transform. a sequence can be passed, in which case the wavelet will be used at the corresponding axis.</p> required <code>pad_mode</code> <code>str</code> <p>padding mode used during computation. Defaults to \"symmetric\".</p> <code>'symmetric'</code> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>array reconstructed from input coefficients.</p>"},{"location":"documentation/dwt/#single-level-transforms","title":"Single level Transforms","text":""},{"location":"documentation/dwt/#calcite.dwt.dwt","title":"<code>calcite.dwt.dwt(x, dec_pairs, pad_mode)</code>","text":"<p>Compute the (single level) discrete wavelet transform for the input array.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Array</code> <p>input array</p> required <code>dec_pairs</code> <code>Tuple[Array, Array] | Sequence[Tuple[Array, Array]]</code> <p>pairs of (low-pass, high-pass) deconstruction filters</p> required <code>pad_mode</code> <code>str</code> <p>padding mode used during computation</p> required <p>Returns:</p> Type Description <code>Tuple[Array, ...]</code> <p>tuple of 1 approximation, then N detail coefficient arrays</p>"},{"location":"documentation/dwt/#calcite.dwt.dwt_1d","title":"<code>calcite.dwt.dwt_1d(x, dec_lo, dec_hi, pad_mode)</code>","text":"<p>Do 1-dimensional discrete wavelet transform on input array, <code>x</code>.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Array</code> <p>input array, should be 1d.</p> required <code>dec_lo</code> <code>Array</code> <p>low-pass filter</p> required <code>dec_hi</code> <code>Array</code> <p>high-pass filter</p> required <code>pad_mode</code> <code>str</code> <p>padding mode.</p> required <p>Returns:</p> Type Description <code>Tuple[Array, Array]</code> <p>Tuple[Array, Array]: approximate, detail coefficients</p>"},{"location":"documentation/dwt/#calcite.dwt.idwt_1d","title":"<code>calcite.dwt.idwt_1d(c_a, c_d, rec_lo, rec_hi, pad_mode, recon_odd)</code>","text":"<p>Inverse discrete wavelet transform in one-dimension.</p> <p>Parameters:</p> Name Type Description Default <code>c_a</code> <code>Array</code> <p>approximation coefficient array</p> required <code>c_d</code> <code>Array</code> <p>detail coefficient array</p> required <code>rec_lo</code> <code>Array</code> <p>low-pass reconstruction filter</p> required <code>rec_hi</code> <code>Array</code> <p>high-pass reconstruction filter</p> required <code>pad_mode</code> <code>str</code> <p>padding mode used during computation.</p> required <p>Returns:</p> Type Description <code>Num[Array, ' s']</code> <p>Array</p>"},{"location":"documentation/dwt/#calcite.dwt.dwt_2d","title":"<code>calcite.dwt.dwt_2d(x, dec_lo, dec_hi, dec_lo_row, dec_hi_row, pad_mode)</code>","text":"<p>Do 2-dimensional discrete wavelet transform on input array, <code>x</code>.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Array</code> <p>input array, should be 1d.</p> required <code>dec_lo</code> <code>Array</code> <p>low-pass filter</p> required <code>dec_hi</code> <code>Array</code> <p>high-pass filter</p> required <code>pad_mode</code> <code>str</code> <p>padding mode.</p> required <p>Returns:</p> Type Description <code>Tuple[Array, Array, Array, Array]</code> <p>Tuple[Array, Array, Array, Array]: c_aa, c_da, c_ad, c_dd</p>"},{"location":"documentation/dwt/#calcite.dwt.idwt_2d","title":"<code>calcite.dwt.idwt_2d(c_aa, c_da, c_ad, c_dd, rec_lo, rec_hi, rec_lo_row, rec_hi_row, pad_mode, recon_odd=(False, False))</code>","text":"<p>Inverse discrete wavelet transform in 2-dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>c_aa</code> <code>Array</code> <p>approximation coefficient</p> required <code>c_da</code> <code>Array</code> <p>detail coefficient c_da</p> required <code>c_ad</code> <code>Array</code> <p>detail coefficient c_ad</p> required <code>c_dd</code> <code>Array</code> <p>detail coefficient c_dd</p> required <code>rec_lo</code> <code>Array</code> <p>low-pass reconstruction filter</p> required <code>rec_hi</code> <code>Array</code> <p>high-pass reconstruction filter</p> required <code>pad_mode</code> <code>str</code> <p>padding mode used during computation</p> required <p>Returns:</p> Name Type Description <code>Array</code> <code>Num[Array, 'y x']</code> <p>reconstructed array</p>"},{"location":"documentation/dwt/#calcite.dwt.dwt_3d","title":"<code>calcite.dwt.dwt_3d(x, dec_lo, dec_hi, dec_lo_row, dec_hi_row, dec_lo_z, dec_hi_z, pad_mode)</code>","text":"<p>Do 3-dimensional discrete wavelet transform on input array, <code>x</code>.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Array</code> <p>input array, should be 1d.</p> required <code>dec_lo</code> <code>Array</code> <p>low-pass filter</p> required <code>dec_hi</code> <code>Array</code> <p>high-pass filter</p> required <code>pad_mode</code> <code>str</code> <p>padding mode.</p> required <p>Returns:</p> Type Description <code>Tuple[Array, Array, Array, Array, Array, Array, Array, Array]</code> <p>Tuple[Array, Array, Array, Array, Array, Array, Array, Array]: c_aaa, c_aad, c_ada, c_add, c_daa, c_dad, c_dda, c_ddd</p>"},{"location":"documentation/dwt/#calcite.dwt.idwt_3d","title":"<code>calcite.dwt.idwt_3d(c_aaa, c_aad, c_ada, c_add, c_daa, c_dad, c_dda, c_ddd, rec_lo, rec_hi, rec_lo_row, rec_hi_row, rec_lo_z, rec_hi_z, pad_mode, recon_odd=(False, False, False))</code>","text":"<p>Inverse discrete wavelet transform in 3 dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>c_aaa</code> <code>Array</code> <p>approximation coefficient array, c_aaa</p> required <code>c_aad</code> <code>Array</code> <p>detail coefficient array, c_aad</p> required <code>c_ada</code> <code>Array</code> <p>detail coefficient array, c_ada</p> required <code>c_add</code> <code>Array</code> <p>detail coefficient array, c_add</p> required <code>c_daa</code> <code>Array</code> <p>detail coefficient array, c_daa</p> required <code>c_dad</code> <code>Array</code> <p>detail coefficient array, c_dad</p> required <code>c_dda</code> <code>Array</code> <p>detail coefficient array, c_dda</p> required <code>c_ddd</code> <code>Array</code> <p>detail coefficient array, c_ddd</p> required <code>rec_lo</code> <code>Array</code> <p>low-pass reconstruction filter</p> required <code>rec_hi</code> <code>Array</code> <p>high-pass reconstruction filter</p> required <code>pad_mode</code> <code>str</code> <p>padding mode used during computation</p> required <p>Returns:</p> Name Type Description <code>Array</code> <code>Num[Array, 'w y x']</code> <p>reconstructed array</p>"},{"location":"documentation/pad/","title":"<code>pad</code>","text":"<p>Utilities for padding arrays.</p>"},{"location":"documentation/pad/#calcite.pad.center_pad_2d","title":"<code>calcite.pad.center_pad_2d(x, adicity, scale)</code>","text":"<p>Center-pad the input array to prevent convolution artifacts.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Num[Array]</code> <p>input array, must be at least 2D</p> required <code>adicity</code> <code>int</code> <p>adicity of scale separation</p> required <code>scale</code> <code>int</code> <p>scale to pad for</p> required <p>Returns:</p> Type Description <code>Num[Array, ...]</code> <p>Num[Array, \"...\"]: center-padded image</p>"},{"location":"documentation/pad/#calcite.pad.uncenter_pad","title":"<code>calcite.pad.uncenter_pad(y, shape)</code>","text":"<p>Remove center padding of input array.</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>Num[Array]</code> <p>input array to have padding removed</p> required <code>shape</code> <code>Iterable[int] | int</code> <p>original shape of previously-padded dimensions, before they were padded</p> required <p>Returns:</p> Type Description <code>Num[Array, ...]</code> <p>Num[Array]</p>"},{"location":"documentation/pad/#calcite.pad.padded_shape","title":"<code>calcite.pad.padded_shape(shape, adicity, scale)</code>","text":"<p>Compute the shape of the padded array.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>Iterable[int]</code> <p>shape of input array in dimensions to pad</p> required <code>adicity</code> <code>int</code> <p>adicity of the scale separation</p> required <code>scale</code> <code>int</code> <p>(max) scale to pad for</p> required <p>Returns:</p> Type Description <code>int | List[int]</code> <p>int|List[int]</p>"},{"location":"documentation/pad/#calcite.pad.pad_for_dwt","title":"<code>calcite.pad.pad_for_dwt(x, size, mode)</code>","text":"<p>Pad the input vector for downstream application of discrete wavelet transform.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Num[Array, &amp;quot; s&amp;quot;]</code> <p>the input vector to be padded</p> required <code>size</code> <code>int</code> <p>size of padding (will be applied to both sides)</p> required <code>mode</code> <code>str</code> <p>padding mode</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if invalid padding mode specified</p> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>padded input</p>"},{"location":"documentation/periodize/","title":"<code>periodize</code>","text":""},{"location":"documentation/periodize/#calcite.periodize.periodize_filter","title":"<code>calcite.periodize.periodize_filter(num_spatial_dims, x, adicity, j)</code>","text":"<p>Periodize the input fourier-domain input filter.</p> <p>Parameters:</p> Name Type Description Default <code>num_spatial_dims</code> <code>int</code> <p>number of spatial dimensions in input.</p> required <code>x</code> <code>Array</code> <p>input array</p> required <code>adicity</code> <code>int</code> <p>adicity of scale separation</p> required <code>j</code> <code>int</code> <p>scale to periodize to (actual will be adicity**j)</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if spatial dimensions &lt;1 or &gt;3</p> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>periodized filter</p>"},{"location":"documentation/qsampling/","title":"<code>qsampling</code>","text":""},{"location":"documentation/qsampling/#calcite.qsampling.optimize_singleshell","title":"<code>calcite.qsampling.optimize_singleshell(num_pts, max_iter=100, antipodal=True, init_points=None)</code>","text":"<p>Find optimal sampling for a single three-dimensional shell.</p> <p>Parameters:</p> Name Type Description Default <code>num_pts</code> <code>int</code> <p>number of points.</p> required <code>max_iter</code> <code>int</code> <p>maximum # of iterations to optimize for. Defaults to 100.</p> <code>100</code> <code>antipodal</code> <code>bool</code> <p>. Defaults to True.</p> <code>True</code> <code>init_points</code> <code>ndarray | None</code> <p>initial points for optimization. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: points</p>"},{"location":"documentation/qsampling/#calcite.qsampling.optimize_multishell","title":"<code>calcite.qsampling.optimize_multishell(num_shells, num_pts_per_shell, weights, max_iter=100, antipodal=True, init_points=None)</code>","text":"<p>Do the optimization to find optimal sampling for a multishell configuration in three dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>num_shells</code> <code>int</code> required <code>num_pts_per_shell</code> <code>List[int]</code> required <code>weights</code> <code>ndarray</code> <p>description</p> required <code>max_iter</code> <code>int</code> <p>maximum # of iterations to run for. Defaults to 100.</p> <code>100</code> <code>antipodal</code> <code>bool</code> <p>description. Defaults to True.</p> <code>True</code> <code>init_points</code> <code>ndarray | None</code> <p>initial points for optimization. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: optimized sampling points (N,3)</p>"},{"location":"documentation/qsampling/#calcite.qsampling.optimize_multishell--of-shells","title":"of shells","text":""},{"location":"documentation/qsampling/#calcite.qsampling.optimize_multishell--of-points-in-each-shell","title":"of points in each shell","text":""},{"location":"documentation/util/","title":"<code>util</code>","text":"<p>Public utility functions from the library. Things that are generally useful for working with other functions from the library.</p>"},{"location":"documentation/util/#calcite.util.ifft_centered","title":"<code>calcite.util.ifft_centered(centered_fft)</code>","text":"<p>Inverse fft of a centered fft, using jnp.roll.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if input is not a 2D or 3D array</p> <p>Returns:</p> Type Description <code>Complex[Array, ...]</code> <p>Complex[Array]</p>"},{"location":"documentation/util/#calcite.util.polarize2d","title":"<code>calcite.util.polarize2d(wvlet, positive, y_axis=True, centered=False)</code>","text":"<p>Make input, double-sided fourier domain wavelet into single-sided version.</p> <p>Parameters:</p> Name Type Description Default <code>wvlet</code> <code>Array</code> <p>input wavelet, should be fourier domain</p> required <code>positive</code> <code>bool</code> <p>whether to take the positive or negative side (positive if True, negative if False)</p> required <code>y_axis</code> <code>bool</code> <p>split along y-axis. Defaults to True.</p> <code>True</code> <code>centered</code> <code>bool</code> <p>whether or not input wavelet is centered in fourier domain. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>single-sided version of wavelet</p>"},{"location":"documentation/util/#calcite.util.polarize_filter_bank_2d","title":"<code>calcite.util.polarize_filter_bank_2d(bank, positive, y_axis=True, centered=False, filter=False)</code>","text":"<p>Polarize all of the filters in the filter bank into positive and negative versions.</p> <p>Polarization as is done here is described in [1].</p> <p>[1]: Bekkers, Erik, et al. \"A multi-orientation analysis approach to retinal vessel tracking.\" Journal of Mathematical Imaging and Vision 49 (2014): 583-610.</p> <p>Parameters:</p> Name Type Description Default <code>bank</code> <code>Array</code> <p>input filter bank of double-sided filters</p> required <code>y_axis</code> <code>bool</code> <p>polarize along y-axis in fourier domain (breaks pi, 2pi symmetry). Defaults to True.</p> <code>True</code> <code>centered</code> <code>bool</code> <p>filters in input bank are centered in fourier space. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>input bank, but with single-sided filters. output will have extra dimension of size 2 in last \"filter dimension\" corresponding to positive &amp; negative versions of filter. for example, if input was [N x M x size_h x size_w], output will be [N x M x 2 x size_h x size_w]</p>"},{"location":"documentation/ios/filter/","title":"<code>ios.filter</code>","text":"<p>Filtering functions based on left-invariant image processing of orientation scores.</p>"},{"location":"documentation/ios/filter/#lid-os","title":"LID-OS","text":"<p>Left-invariant derivative on orientation scores (LIDOS) filters.</p>"},{"location":"documentation/ios/filter/#calcite.ios.filter.lidos2","title":"<code>calcite.ios.filter.lidos2(ori_score, thetas, sigma_o, sigma_s, normalize=False)</code>","text":"<p>Compute the 2D left-invariant derivative on orientation scores (LID-OS) filter on the input orientations scores.</p> <p>Parameters:</p> Name Type Description Default <code>ori_score</code> <code>Float[Array, 't y x']</code> <p>orientation score array.</p> required <code>thetas</code> <code>Float[Array, t]</code> <p>angles sampled to generate orientation scores.</p> required <code>sigma_o</code> <code>float</code> <p>standard deviation of Gaussian used to blur orientation axis.</p> required <code>sigma_s</code> <code>float</code> <p>standard deviation of Gaussian used to blur spatial axes.</p> required <code>normalize</code> <code>bool</code> <p>normalize the filter response.</p> <code>False</code> <p>Returns:</p> Type Description <code>Float[Array, 't y x']</code> <p>Float[Array, \"t y x\"]</p>"},{"location":"documentation/ios/filter/#calcite.ios.filter.multiscale_lidos2","title":"<code>calcite.ios.filter.multiscale_lidos2(ori_score, thetas, sigma_o, sigma_s, normalize=False)</code>","text":"<p>Compute the multi-scale LID-OS filter and do image reconstruction on the input orientation scores.</p> <p>Parameters:</p> Name Type Description Default <code>ori_score</code> <code>Float[Array, 't y x']</code> <p>array of orientation scores, where the angle is the first dimension and the spatial dimensions are the last two.</p> required <code>thetas</code> <code>Float[Array, a]</code> <p>array of angles that was used to compute the orientation scores, corresponds to the first dimension of <code>ori_score</code>.</p> required <code>sigma_o</code> <code>float</code> <p>standard deviation of Gaussian used to blur orientation axis.</p> required <code>sigma_s</code> <code>Sequence[float]</code> <p>per-scale standard deviation of Gaussians used to blur spatial axes.</p> required <code>normalize</code> <code>bool</code> <p>whether to normalize the scores at each scale or not. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Float[Array, 'y x']</code> <p>Float[Array, \"y x\"]: reconstructed image.</p>"},{"location":"documentation/ios/filter/#lad-os","title":"LAD-OS","text":"<p>Locally adaptive derivative on orientation scores (LADOS) filters.</p>"},{"location":"documentation/ios/filter/#calcite.ios.filter.lados2","title":"<code>calcite.ios.filter.lados2(ori_score, thetas, sigma_o, sigma_s, mu, normalize=False)</code>","text":"<p>Compute the 2D LAD-OS filter on the input orientation scores.</p> <p>Parameters:</p> Name Type Description Default <code>ori_score</code> <code>Float[Array, 't y x']</code> <p>array of orientation scores, where the angle is the first dimension and the spatial dimensions are the last two.</p> required <code>thetas</code> <code>Float[Array, a]</code> <p>array of angles that was used to compute the orientation scores, corresponds to the first dimension of <code>ori_score</code>.</p> required <code>sigma_o</code> <code>float</code> <p>standard deviation of Gaussian used to blur orientation axis.</p> required <code>sigma_s</code> <code>float</code> <p>standard deviation of Gaussian used to blur spatial axes.</p> required <code>mu</code> <code>float</code> <p>intrinsic parameter to balance spatial and orientation distances.</p> required <code>normalize</code> <code>bool</code> <p>whether to normalize the scores at each scale or not. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Float[Array, 't y x']</code> <p>Float[Array, \"t y x\"]</p>"},{"location":"documentation/ios/filter/#calcite.ios.filter.multiscale_lados2","title":"<code>calcite.ios.filter.multiscale_lados2(ori_score, thetas, sigma_o, sigma_s, mu, normalize=False)</code>","text":"<p>Compute the multi-scale LAD-OS filter and do image reconstruction on the input orientation scores.</p> <p>Parameters:</p> Name Type Description Default <code>ori_score</code> <code>Float[Array, 't y x']</code> <p>array of orientation scores, where the angle is the first dimension and the spatial dimensions are the last two.</p> required <code>thetas</code> <code>Float[Array, a]</code> <p>array of angles that was used to compute the orientation scores, corresponds to the first dimension of <code>ori_score</code>.</p> required <code>sigma_o</code> <code>float</code> <p>standard deviation of Gaussian used to blur orientation axis.</p> required <code>sigma_s</code> <code>Sequence[float]</code> <p>per-scale standard deviation of Gaussians used to blur spatial axes.</p> required <code>normalize</code> <code>bool</code> <p>whether to normalize the scores at each scale or not. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Float[Array, 'y x']</code> <p>Float[Array, \"y x\"]</p>"},{"location":"documentation/ios/lad/","title":"<code>ios.lad</code>","text":"<p>Locally adaptive derivative frames in the roto-translation group.</p>"},{"location":"documentation/ios/lad/#frames","title":"Frames","text":""},{"location":"documentation/ios/lad/#calcite.ios.lad.locally_adaptive_derivative_frame2","title":"<code>calcite.ios.lad.locally_adaptive_derivative_frame2(ori_score, thetas, sigma_o, sigma_s, mu)</code>","text":"<p>Calculate the locally adaptive derivative frame (LAD) for the orientation score input, <code>ori_score</code>, of some original 2D image.</p> <p>Parameters:</p> Name Type Description Default <code>ori_score</code> <code>Float[Array, 't y x']</code> <p>array of orientation scores, where the angle is the first dimension and the spatial dimensions are the last two.</p> required <code>thetas</code> <code>Float[Array, a]</code> <p>array of angles that was used to compute the orientation scores, corresponds to the first dimension of <code>ori_score</code>.</p> required <code>mu</code> <code>float</code> <p>intrinsic parameter to balance spatial and orientation distances (has dimension 1/length, see <code>mu_matrix</code>.)</p> required <code>sigma_o</code> <code>float</code> <p>standard deviation of Gaussian used to blur orientation axis.</p> required <code>sigma_s</code> <code>float</code> <p>standard deviation of Gaussian used to blur spatial axes.</p> required <p>Returns:</p> Type Description <code>Float[Array, 't y x 3 3']</code> <p>Float[Array, \"t y x 3 3\"]: LAD frame, (d_a, d_b, d_c) at each point in orientation space.</p>"},{"location":"documentation/ios/lad/#frame-construction-utilities","title":"Frame Construction Utilities","text":"<p>Functions used for computing the locally adaptive frames.</p>"},{"location":"documentation/ios/lad/#calcite.ios.lad.optimal_tangent_vector2","title":"<code>calcite.ios.lad.optimal_tangent_vector2(ori_score, thetas, sigma_o, sigma_s, mu)</code>","text":"<p>Calculate optimal tangent vectors, used to define the LAD frame, at each point in orientation space.</p> <p>Parameters:</p> Name Type Description Default <code>ori_score</code> <code>Float[Array, 't y x']</code> <p>orientation scores.</p> required <code>thetas</code> <code>Float[Array, a]</code> <p>angles used to compute orientation</p> required <code>sigma_o</code> <code>float</code> <p>standard deviation of Gaussian used to blur orientation axis.</p> required <code>sigma_s</code> <code>float</code> <p>standard deviation of Gaussian used to blur spatial axes.</p> required <code>mu</code> <code>Float</code> <p>intrinsic parameter to balance spatial and orientation distances (has dimension 1/length, see <code>mu_matrix</code>.).</p> required <p>Returns:</p> Type Description <code>Float[Array, 't y x 3']</code> <p>Float[Array, \"t y x 3\"]: optimal tangent vector at each point in orientation space.</p>"},{"location":"documentation/ios/lad/#calcite.ios.lad.symmetrized_mu_normalized_left_invariant_hessian2","title":"<code>calcite.ios.lad.symmetrized_mu_normalized_left_invariant_hessian2(hessian, mu)</code>","text":"<p>Symmetrize and normalize the hessian matrix, <code>hessian</code>.</p> <p>Parameters:</p> Name Type Description Default <code>hessian</code> <code>Float[Array, 't y x 3 3']</code> required <code>mu</code> <code>float</code> <p>intrinsic parameter to balance spatial and orientation distances (has dimension 1/length, see <code>mu_matrix</code>.)</p> required <p>Returns:     Float[Array, \"t y x 3 3\"]</p> Notes <p>See Eqn. 6 of [1].</p> References <p>[1] Zhang, Jiong, et al. \"Robust retinal vessel segmentation via locally adaptive derivative frames in orientation scores.\" IEEE transactions on medical imaging 35.12 (2016): 2631-2644.</p>"},{"location":"documentation/ios/lad/#calcite.ios.lad.mu_matrix","title":"<code>calcite.ios.lad.mu_matrix(mu)</code>","text":"<p>Construct diagonal matrix for balancing spatial and orientation distances when computing gradients.</p> <p>This matrix is diag([1/mu, 1/mu, 1]), so mu should be set such that it will normalize distances to the same spacing as the angles sampled in orientation space.</p> <p>Parameters:</p> Name Type Description Default <code>mu</code> <code>float</code> <p>intrinsic parameter to balance spatial and orientation distances (has dimension 1/length).</p> required <p>Returns:</p> Type Description <code>Float[Array, '3 3']</code> <p>Float[Array, \"3 3\"]</p>"},{"location":"documentation/ios/lad/#calcite.ios.lad.kappa","title":"<code>calcite.ios.lad.kappa(c)</code>","text":"<p>Compute the local curvature from the tangent vector, <code>c</code>.</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>Float[Array, 't y x 3']</code> <p>tangent vector array at each point in orientation space.</p> required <p>Returns:</p> Type Description <code>Float[Array, 't y x']</code> <p>Float[Array, \"t y x\"]: local curvature at each point in orientation space.</p> Notes <p>See Eqn. 7 of [1].</p> References <p>[1] Zhang, Jiong, et al. \"Robust retinal vessel segmentation via locally adaptive derivative frames in orientation scores.\" IEEE transactions on medical imaging 35.12 (2016): 2631-2644.</p>"},{"location":"documentation/ios/lad/#calcite.ios.lad.d_h","title":"<code>calcite.ios.lad.d_h(c)</code>","text":"<p>Compute deviation from horizontality for tanget vectors, c.</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>Float[Array, 't y x 3']</code> <p>tangent vector array at each point in orientation space.</p> required <p>Returns:</p> Type Description <code>Float[Array, 't y x']</code> <p>Float[Array, \"t y x\"]: deviation from horizontality at each point in orientation space.</p> Notes <p>See Eqn. 7 of [1].</p> References <p>[1] Zhang, Jiong, et al. \"Robust retinal vessel segmentation via locally adaptive derivative frames in orientation scores.\" IEEE transactions on medical imaging 35.12 (2016): 2631-2644.</p>"},{"location":"documentation/ios/lad/#calcite.ios.lad.r_dh","title":"<code>calcite.ios.lad.r_dh(d_h)</code>","text":"<p>Compute R_{d_h} matrix for rotating the LID frame into the LAD frame.</p> <p>Parameters:</p> Name Type Description Default <code>d_h</code> <code>Float[Array, 't y x']</code> <p>local deviatino from horizontality at each pixel.</p> required <p>Returns:</p> Type Description <code>Float[Array, 't y x 3 3']</code> <p>Float[Array, \"t y x 3 3\"]: rotation matrix @ each pixel.</p>"},{"location":"documentation/ios/lad/#calcite.ios.lad.q_kappamu","title":"<code>calcite.ios.lad.q_kappamu(kappa, mu)</code>","text":"<p>Compute Q_{\\kappa,\\mu} matrix for rotating the LID frame into the LAD frame.</p> <p>Parameters:</p> Name Type Description Default <code>kappa</code> <code>Float[Array, 'a b']</code> <p>local curvature at each pixel, kappa.</p> required <code>mu</code> <code>Float</code> <p>intrinsic parameter to balance spatial and orientation distances (has dimension 1/length, see <code>mu_matrix</code>.)</p> required <p>Returns:</p> Type Description <code>Float[Array, 't y x 3 3']</code> <p>Float[Array, \"t y x 3 3\"]: rotation matrix @ each pixel.</p>"},{"location":"documentation/ios/lid/","title":"<code>ios.lid</code>","text":"<p>Left-invariant derivatives and frames.</p>"},{"location":"documentation/ios/lid/#derivative-frames","title":"Derivative Frames","text":""},{"location":"documentation/ios/lid/#calcite.ios.lid.left_invariant_derivative_frame2","title":"<code>calcite.ios.lid.left_invariant_derivative_frame2(ori_score, thetas, sigma_o, sigma_s)</code>","text":"<p>Compute the pixel-wise left-invariant derivative for the input orientation scores. Creates the left-invariant rotating derivative (LID) frame of reference.</p> <p>Parameters:</p> Name Type Description Default <code>ori_score</code> <code>Float[Array, 't y x']</code> <p>array of orientation scores, where the angle is the first dimension and the spatial dimensions are the last two.</p> required <code>thetas</code> <code>Float[Array, a]</code> <p>array of angles that was used to compute the orientation scores, corresponds to the first dimension of <code>ori_score</code>.</p> required <code>sigma_o</code> <code>float</code> <p>standard deviation of Gaussian used to blur orientation axis.</p> required <code>sigma_s</code> <code>float</code> <p>standard deviation of Gaussian used to blur spatial axes.</p> required <p>Returns:</p> Type Description <code>Float[Array, 't y x 3']</code> <p>Float[Array, \"t y x 3\"]: A 4D matrix where the first 3 dimensions match those of the input ori_score, and the last is size-3 and has the (d_zeta, d_eta, dt) components of the derivative.</p> Notes <p>See Eqn. 1 of [1] for details and how this is constructed. If <code>sigma_s</code> and <code>sigma_o</code> are zero, <code>jnp.gradient</code> will be used to calculate derivatives. Otherwise, uses an order-1 Gaussian filter.</p> References <p>[1] Zhang, Jiong, et al. \"Robust retinal vessel segmentation via locally adaptive derivative frames in orientation scores.\" IEEE transactions on medical imaging 35.12 (2016): 2631-2644.</p>"},{"location":"documentation/ios/lid/#calcite.ios.lid.left_invariant_derivative_frame2","title":"<code>calcite.ios.lid.left_invariant_derivative_frame2(ori_score, thetas, sigma_o, sigma_s)</code>","text":"<p>Compute the pixel-wise left-invariant derivative for the input orientation scores. Creates the left-invariant rotating derivative (LID) frame of reference.</p> <p>Parameters:</p> Name Type Description Default <code>ori_score</code> <code>Float[Array, 't y x']</code> <p>array of orientation scores, where the angle is the first dimension and the spatial dimensions are the last two.</p> required <code>thetas</code> <code>Float[Array, a]</code> <p>array of angles that was used to compute the orientation scores, corresponds to the first dimension of <code>ori_score</code>.</p> required <code>sigma_o</code> <code>float</code> <p>standard deviation of Gaussian used to blur orientation axis.</p> required <code>sigma_s</code> <code>float</code> <p>standard deviation of Gaussian used to blur spatial axes.</p> required <p>Returns:</p> Type Description <code>Float[Array, 't y x 3']</code> <p>Float[Array, \"t y x 3\"]: A 4D matrix where the first 3 dimensions match those of the input ori_score, and the last is size-3 and has the (d_zeta, d_eta, dt) components of the derivative.</p> Notes <p>See Eqn. 1 of [1] for details and how this is constructed. If <code>sigma_s</code> and <code>sigma_o</code> are zero, <code>jnp.gradient</code> will be used to calculate derivatives. Otherwise, uses an order-1 Gaussian filter.</p> References <p>[1] Zhang, Jiong, et al. \"Robust retinal vessel segmentation via locally adaptive derivative frames in orientation scores.\" IEEE transactions on medical imaging 35.12 (2016): 2631-2644.</p>"},{"location":"documentation/ios/lid/#hessians","title":"Hessians","text":""},{"location":"documentation/ios/lid/#calcite.ios.lid.left_invariant_hessian2","title":"<code>calcite.ios.lid.left_invariant_hessian2(ori_score, thetas, sigma_o, sigma_s)</code>","text":"<p>Compute the pixel-wise left-invariant Hessian for the input orientation scores.</p> <p>Parameters:</p> Name Type Description Default <code>ori_score</code> <code>Float[Array, 't y x']</code> <p>array of orientation scores, where the angle is the first dimension and the spatial dimensions are the last two.</p> required <code>thetas</code> <code>Float[Array, a]</code> <p>array of angles that was used to compute the orientation scores, corresponds to the first dimension of <code>ori_score</code>.</p> required <code>sigma_o</code> <code>float</code> <p>standard deviation of Gaussian used to blur orientation axis.</p> required <code>sigma_s</code> <code>float</code> <p>standard deviation of Gaussian used to blur spatial axes.</p> required <p>Returns:</p> Type Description <code>Float[Array, 't y x 3 3']</code> <p>Float[Array, \"t y x 3 3\"]: A 5D matrix where the first 3 dimensions match those of the input ori_score, and the last two correspond to the components of the Hessian.</p>"},{"location":"documentation/scatter/fourier/","title":"<code>scatter.fourier</code>","text":"<p>Fourier-space calculation of the scattering transform.</p>"},{"location":"documentation/scatter/fourier/#calcite.scatter.fourier.scattering_fields","title":"<code>calcite.scatter.fourier.scattering_fields(x, adicity, num_scales, num_spatial_dims, psi1, psi2=None, nonlinearity=complex_modulus)</code>","text":"<p>Compute scattering fields.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Array</code> <p>input array</p> required <code>adicity</code> <code>int</code> <p>adicity of scale separation</p> required <code>num_scales</code> <code>int</code> <p>number of scales to compute fields over</p> required <code>num_spatial_dims</code> <code>int</code> <p>number of spatial dimensions in input array (and filters).</p> required <code>psi1</code> <code>Array</code> <p>wavelet filter bank for first layer</p> required <code>psi2</code> <code>Array</code> <p>wavelet filter bank for second layer</p> <code>None</code> <code>nonlinearity</code> <code>Callable[[Array], Array]</code> <p>nonlinearity to use after each wavelet transform. Defaults to complex modulus.</p> <code>complex_modulus</code> <p>Raises:     ValueError: if image width or height isn't evenly divisible by adicity^(n_scales)</p> <p>Returns:</p> Type Description <code>Tuple[List[Array], List[List[Array]]]</code> <p>Tuple[List[Array],List[List[Array]]]: tuple where first element is list of fields at first layer of transform, second is list of lists of fields at second layer of transform.</p>"},{"location":"documentation/scatter/fourier/#calcite.scatter.fourier.scattering_coeffs","title":"<code>calcite.scatter.fourier.scattering_coeffs(x, adicity, num_scales, num_spatial_dims, phi, psi1, psi2=None, strategy='breadth', reduction='local', nonlinearity=complex_modulus)</code>","text":"<p>Compute scattering coefficients for input field, <code>x</code>.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Array</code> <p>input tensor. Coefficients are computed on last 2 dimensions. Should be Fourier domain.</p> required <code>adicity</code> <code>int</code> <p>logarithm-base used for scale separation.</p> required <code>num_scales</code> <code>int</code> <p>number of scales to compute the scattering over</p> required <code>num_spatial_dims</code> <code>int</code> <p>number of spatial dimensions in the input tensor (and filters).</p> required <code>phi</code> <code>Array</code> <p>low pass output filter.</p> required <code>psi1</code> <code>Array</code> <p>wavelet filters for first scattering field.</p> required <code>psi2</code> <code>Array</code> <p>wavelet filters for 2nd scattering. Defaults to None (psi1 is re-used).</p> <code>None</code> <code>strategy</code> <code>str</code> <p>whether computation is done breadth- or depth-first down the scattering tree. Defaults to \"breadth\".</p> <code>'breadth'</code> <code>reduction</code> <code>str</code> <p>how to reduce the fields to scattering coefficients. Either \"local\" or \"global\". Defaults to \"local\".</p> <code>'local'</code> <code>nonlinearity</code> <code>Callable[[Array], Array]</code> <p>nonlinearity to use after each wavelet transform. Defaults to complex modulus.</p> <code>complex_modulus</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if specified computation strategy isn't \"breadth\" or \"depth\"</p> <code>ValueError</code> <p>if image width or height isn't evenly divisible by adicity^(n_scales)</p> <p>Returns:</p> Type Description <code>Tuple[Real[Array, ...], Real[Array, ...], List[Real[Array, ...]]]</code> <p>Tuple[Real[Array, \"...\"], Real[Array, \"...\"], Real[Array, \"...\"]]</p>"},{"location":"documentation/scatter/fourier/#calcite.scatter.fourier.complex_modulus","title":"<code>calcite.scatter.fourier.complex_modulus(x)</code>","text":"<p>Compute modulus of scattering field.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Complex[Array]</code> <p>input field.</p> required <p>Returns:</p> Type Description <code>Complex[Array, ...]</code> <p>Real[Array]</p>"},{"location":"documentation/scatter/real/","title":"<code>scatter.real</code>","text":""},{"location":"documentation/scatter/real/#scattering-functions","title":"Scattering Functions","text":""},{"location":"documentation/scatter/real/#calcite.scatter.real2d.scattering_coeffs","title":"<code>calcite.scatter.real2d.scattering_coeffs(x, adicity, n_scales, phi, psi1, psi2=None, reduction='local', conv_method='fft', nonlinearity=complex_modulus)</code>","text":"<p>Compute scattering coefficients for input.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Real[Array]</code> <p>input image(s) tensor</p> required <code>adicity</code> <code>int</code> <p>logarithm-base used for scale separation.</p> required <code>n_scales</code> <code>int</code> <p>number of scales to compute the scattering over</p> required <code>phi</code> <code>Complex[Array, 'h w']</code> <p>low pass output filter.</p> required <code>psi1</code> <code>Complex[Array, '{n_scales} l h w']</code> <p>wavelet filters for first scattering field.</p> required <code>psi2</code> <code>Complex[Array, '{n_scales} l h w']</code> <p>wavelet filters for 2nd scattering. Defaults to None (psi1 is re-used).</p> <code>None</code> <code>reduction</code> <code>str</code> <p>how to reduce the fields to scattering coefficients. Either \"local\" or \"global\". Defaults to \"local\".</p> <code>'local'</code> <code>conv_method</code> <code>str</code> <p>method for computing convolutions. Defaults to 'fft'.</p> <code>'fft'</code> <code>nonlinearity</code> <code>Callable[[Array], Array]</code> <p>nonlinearity to use after each wavelet transform. Defaults to complex modulus.</p> <code>complex_modulus</code> <p>Returns:</p> Type Description <code>Tuple[Array, Array, List[Array]]</code> <p>Tuple[Array, Array, List[Array]]: 0th, 1st, 2nd order scattering coefficients.</p>"},{"location":"documentation/scatter/real/#calcite.scatter.real2d.scattering_fields","title":"<code>calcite.scatter.real2d.scattering_fields(x, adicity, n_scales, psi1, psi2=None, conv_method='fft', nonlinearity=complex_modulus)</code>","text":"<p>Compute scattering fields.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Real[Array]</code> <p>input array, should be 4D</p> required <code>adicity</code> <code>int</code> <p>adicity of scale separation</p> required <code>n_scales</code> <code>int</code> <p>number of scales to compute fields over</p> required <code>psi1</code> <code>Complex[Array]</code> <p>wavelet filter bank for 1st layer</p> required <code>psi2</code> <code>Complex[Array]</code> <p>wavelet filter bank for second layer. Defaults to None.</p> <code>None</code> <code>conv_method</code> <code>str</code> <p>method for computing convolutions. Defaults to 'fft'.</p> <code>'fft'</code> <code>nonlinearity</code> <code>Callable[[Array], Array]</code> <p>nonlinearity to use after each wavelet transform. Defaults to complex modulus.</p> <code>complex_modulus</code> <p>Returns:</p> Type Description <code>Tuple[List[Num[Array, 'b c l 1 h w']], List[List[Num[Array, 'b c l m h w']]]]</code> <p>Tuple[List[Num[Array]],List[List[Num[Array]]]]: tuple where first element is list of fields at first layer of transform, second is list of lists of fields at second layer of transform.</p>"},{"location":"documentation/scatter/real/#utilities","title":"Utilities","text":""},{"location":"documentation/scatter/real/#calcite.scatter.real2d.apply_filter_bank","title":"<code>calcite.scatter.real2d.apply_filter_bank(x, psi, mode='same', method='fft')</code>","text":"<p>Apply a bank of filters to all channels &amp; batches in input.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Num[Array]</code> <p>input array (4D)</p> required <code>psi</code> <code>Complex[Array]</code> <p>filter bank (NxHxW)</p> required <code>mode</code> <code>str</code> <p>output mode of convolution. Defaults to 'same'.</p> <code>'same'</code> <code>method</code> <code>str</code> <p>method for computing convolution. Defaults to 'fft'.</p> <code>'fft'</code> <p>Returns:</p> Type Description <code>Complex[Array, 'c l p h w']</code> <p>Complex[Array]: 5D tensor of filter responses, BxCxNxHxW</p>"},{"location":"documentation/scatter/real/#calcite.scatter.real2d.complex_modulus","title":"<code>calcite.scatter.real2d.complex_modulus(x)</code>","text":"<p>Compute complex modulus of input.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Complex[Array]</code> <p>input array</p> required <p>Returns:</p> Type Description <code>Real[Array, ...]</code> <p>Real[Array]</p>"},{"location":"documentation/scatter/real/#calcite.scatter.real2d.batched_conv2d","title":"<code>calcite.scatter.real2d.batched_conv2d(in1, in2, mode='same', method='fft')</code>","text":"<p>2D convolution of inputs, batched.</p> <p>Parameters:</p> Name Type Description Default <code>in1</code> <code>Num[Array]</code> <p>batched images to be convolved on (4+D)</p> required <code>in2</code> <code>Numy[Array]</code> <p>second input, kernel, to convolution (2D)</p> required <code>mode</code> <code>str</code> <p>output mode of convolution. Defaults to 'same'.</p> <code>'same'</code> <code>method</code> <code>str</code> <p>computation method for convolution. Defaults to 'fft'.</p> <code>'fft'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if invalid method is supplied. must be 'fft' or 'direct'</p> <p>Returns:</p> Type Description <code>Num[Array, ...]</code> <p>Num[Array]</p>"},{"location":"documentation/scatter/util/","title":"<code>scatter.util</code>","text":"<p>Utility functions for scattering transforms. These aren't useful for the transform, itself, but for dealing with outputs, misc. data handling, etc.</p>"},{"location":"documentation/scatter/util/#calcite.scatter.util.apply_filter_bank","title":"<code>calcite.scatter.util.apply_filter_bank(num_spatial_dims, x, psi, adicity, scale_subsample, scale_periodize=None)</code>","text":"<p>Apply a bank of filters to all of the channels in the input.</p> <p>Parameters:</p> Name Type Description Default <code>num_spatial_dims</code> <code>int</code> <p>number of spatial dimensions in the input array</p> required <code>x</code> <code>Array</code> <p>input array</p> required <code>scale_subsample</code> <code>int</code> <p>scale to subsample the input by</p> required <code>scale_periodize</code> <code>int | None</code> <p>scale to periodize the filters by. Defaults to None. If None, will be the same as <code>scale_subsample</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>output will be shaped [channels x (filter dimensions) x (spatial dimensions)]</p>"},{"location":"documentation/scatter/util/#calcite.scatter.util.subsample_field","title":"<code>calcite.scatter.util.subsample_field(num_spatial_dims, x, adicity, j)</code>","text":"<p>Subsample an input field by local averaging.</p> <p>Parameters:</p> Name Type Description Default <code>num_spatial_dims</code> <code>int</code> <p>number of spatial dimensions in input.</p> required <code>x</code> <code>Array</code> <p>input array</p> required <code>adicity</code> <code>int</code> <p>adicity of scale separation</p> required <code>j</code> <code>int</code> <p>scale to subsample at (actual will be adicity**j)</p> required <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>subsampled input</p>"},{"location":"documentation/scatter/util/#calcite.scatter.util.flatten_filter_tensor","title":"<code>calcite.scatter.util.flatten_filter_tensor(num_spatial_dims, psi)</code>","text":"<p>Flatten filter parameter channels (along with possible image channels) into a single array axis.</p> <p>Parameters:</p> Name Type Description Default <code>num_spatial_dims</code> <code>int</code> <p>number of spatial dimensions in filter</p> required <code>psi</code> <code>Array</code> <p>filter</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Array</p>"},{"location":"documentation/scatter/util/#calcite.scatter.util.group_fields_by_size","title":"<code>calcite.scatter.util.group_fields_by_size(num_spatial_dims, field1, field2)</code>","text":"<p>Group scattering fields from different layers by size.</p> <p>Parameters:</p> Name Type Description Default <code>field1</code> <code>List[Array]</code> <p>Scattering fields from 1st layer of transform.</p> required <code>field2</code> <code>List[List[Array]]</code> <p>Scattering fields from 2nd layer of transform.</p> required <p>Returns:</p> Type Description <code>List[Array]</code> <p>List[Array]: list of 6D arrays (CLMHW) where elements correspond to the same spatial size, sorted in descending order.</p>"},{"location":"documentation/wavelet/bumpsteer/","title":"<code>wavelet.bumpsteer</code>","text":"<p>\"Bump steerable wavelets.</p> <p>Commonly used in phase harmonic scattering networks. Introduced in [1]. Implementation used here is based on the pyWPH implementation, see [2].</p>"},{"location":"documentation/wavelet/bumpsteer/#references","title":"References","text":"<p>[1] Mallat, St\u00e9phane, Sixin Zhang, and Gaspar Rochette. \"Phase harmonic correlations and convolutional neural networks.\" Information and Inference: A Journal of the IMA 9.3 (2020): 721-747.</p> <p>[2] Regaldo-Saint Blancard, B., Allys, E., Boulanger, F., Levrier, F., &amp; Jeffrey, N. (2021). A new approach for the statistical denoising of Planck interstellar dust polarization data. arXiv:2102.03160</p>"},{"location":"documentation/wavelet/bumpsteer/#calcite.wavelet.bumpsteer.filter_bank_2d","title":"<code>calcite.wavelet.bumpsteer.filter_bank_2d(size_h, size_w, n_scales, n_orientations, n_alphas, delta_n, space, adicity=2, sigma_prefactor=1.0, freq_prefactor=0.85 * math.pi)</code>","text":"<p>Create a filter bank of 2D bump-steerable kernels.</p> <p>Parameters:</p> Name Type Description Default <code>size_h</code> <code>int</code> <p>size of output filters, in rows</p> required <code>size_w</code> <code>int</code> <p>size of output filters, in cols</p> required <code>n_scales</code> <code>int</code> <p>number of scales</p> required <code>n_orientations</code> <code>int</code> <p>number of orientations (must be even)</p> required <code>n_alphas</code> <code>int</code> <p>number of anglular shifts in phase</p> required <code>delta_n</code> <code>int</code> <p>number of spatial shifts in phase</p> required <code>space</code> <code>str</code> <p>output space of filter bank (one of 'real' or 'fourier')</p> required <code>adicity</code> <code>int</code> <p>adicity of scale separation. Defaults to 2.</p> <code>2</code> <code>sigma_prefactor</code> <code>float</code> <p>prefactor for scale-specific sigma parameter. Defaults to 1.0.</p> <code>1.0</code> <code>freq_prefactor</code> <code>float</code> <p>prefactor for scale-specific central frequency parameter. Defaults to 0.85*math.pi.</p> <code>0.85 * pi</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if number of orientations is not even</p> <code>ValueError</code> <p>if output space isn't one of ('real', 'fourier')</p> <p>Returns:</p> Type Description <code>Num[Array, '{n_scales} {n_orientations} {n_alphas} {delta_n} {size_h} {size_w}']</code> <p>Num[Array]: [n_scales x n_orientations x n_alphas x delta_n x size_h x size_w] array of filters</p>"},{"location":"documentation/wavelet/bumpsteer/#real-space","title":"Real Space","text":""},{"location":"documentation/wavelet/bumpsteer/#calcite.wavelet.bumpsteer.bump_steerable_kernel_2d_real","title":"<code>calcite.wavelet.bumpsteer.bump_steerable_kernel_2d_real(size_h, size_w, xi, theta, sigma, n, alpha, ell)</code>","text":"<p>Real-space kernel for 2D bump steerable wavelet.</p> <p>Parameters:</p> Name Type Description Default <code>size_h</code> <code>int</code> <p>spatial size of filter, height, in pixels</p> required <code>size_w</code> <code>int</code> <p>spatial size of filter, width, in pixels</p> required <code>xi</code> <code>float</code> <p>central frequency of filter</p> required <code>theta</code> <code>float</code> <p>angle of filter, in [0, 2*pi]</p> required <code>sigma</code> <code>float</code> <p>bandwidth of filter</p> required <code>n</code> <code>float</code> <p>amount of translation of filter in k-space</p> required <code>alpha</code> <code>float</code> <p>angle of translation of filter, relative to theta</p> required <code>ell</code> <code>int</code> <p>number of filters in bank, in half-plane of angles [0, pi]</p> required <p>Returns:</p> Type Description <code>Num[Array, '{size_h} {size_w}']</code> <p>Num[Array, {size_h} {size_w}]</p>"},{"location":"documentation/wavelet/bumpsteer/#fourier-space","title":"Fourier Space","text":""},{"location":"documentation/wavelet/bumpsteer/#calcite.wavelet.bumpsteer.bump_steerable_kernel_2d_fourier","title":"<code>calcite.wavelet.bumpsteer.bump_steerable_kernel_2d_fourier(size_h, size_w, xi, theta, sigma, n, alpha, ell)</code>","text":"<p>Fourier-space kernel for 2D bump steerable wavelet.</p> <p>Parameters:</p> Name Type Description Default <code>size_h</code> <code>int</code> <p>spatial size of filter, height, in pixels</p> required <code>size_w</code> <code>int</code> <p>spatial size of filter, width, in pixels</p> required <code>xi</code> <code>float</code> <p>central frequency of filter</p> required <code>theta</code> <code>float</code> <p>angle of filter, in [0, 2*pi]</p> required <code>sigma</code> <code>float</code> <p>bandwidth of filter</p> required <code>n</code> <code>float</code> <p>amount of translation of filter in k-space</p> required <code>alpha</code> <code>float</code> <p>angle of translation of filter, relative to theta</p> required <code>ell</code> <code>int</code> <p>number of filters in bank, in half-plane of angles [0, pi]</p> required <p>Returns:</p> Type Description <code>Num[Array, '{size_h} {size_w}']</code> <p>Num[Array, {size_h} {size_w}]</p>"},{"location":"documentation/wavelet/cake/","title":"<code>wavelet.cake</code>","text":"<p>Cake wavelets.</p> <p>2D cake wavelets were introduced in [1], while 3D cake wavelets were introduced in [2].</p>"},{"location":"documentation/wavelet/cake/#references","title":"References","text":"<p>[1] Bekkers, Erik, et al. \"A multi-orientation analysis approach to retinal vessel tracking.\" Journal of Mathematical Imaging and Vision 49 (2014): 583-610.</p> <p>[2] Janssen, Michiel HJ, et al. \"Design and processing of invertible orientation scores of 3D images.\" Journal of mathematical imaging and vision 60 (2018): 1427-1458.</p>"},{"location":"documentation/wavelet/cake/#filter-banks","title":"Filter Banks","text":""},{"location":"documentation/wavelet/cake/#calcite.wavelet.cake.filter_bank_2d","title":"<code>calcite.wavelet.cake.filter_bank_2d(size, n_scales, n_orientations, space, spline_order, overlap_factor, inflection_point_hf, poly_order_hf, inflection_point_lf, poly_order_lf, centered=False)</code>","text":"<p>Create a filter bank of 2D cake kernels.</p> <p>Args:</p> <pre><code>size (int): size of (square) dimension of output\nn_scales (int): number of scales in the filter bank\nn_orientations (int): number of orientations to include in the bank\nspace (str): output space of filters, 'real' or 'fourier'\nspline_order (int): order of b-spline\noverlap_factor (int): sets the amount of overlap between adjacent orientations in the bank\ninflection_point_hf (float): sets the high frequency cutoff of the wavelet\npoly_order_hf (int): order of high frequency filter polynomial. higher orders give a sharper rolloff\ninflection_point_lf (float, optional): sets the low frequency cutoff of the wavelet, defaults to None (no low freq. filtering)\npoly_order_lf (int, optional): order of low frequency filter polynomial. higher orders give a sharper rolloff. defaults to None, which means no low freq. filtering.\ncentered (bool, optional): return filters centered in the output window (as if they had been `fftshift`'d), defaults to False which will match the API of the other wavelets.\n</code></pre> <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>space</code> isn't 'real' or 'fourier'</p> <p>Returns:</p> Type Description <code>Num[Array, '{n_scales} {n_orientations} {size} {size}']</code> <p>Num[Array]: [n_orientations x size x size] array of filters (1 per orientation)</p>"},{"location":"documentation/wavelet/cake/#calcite.wavelet.cake.orientation_bank_2d","title":"<code>calcite.wavelet.cake.orientation_bank_2d(size, n_orientations, space, spline_order, overlap_factor, inflection_point_hf, poly_order_hf, inflection_point_lf, poly_order_lf, centered=False, return_angles=False)</code>","text":"<p>Create a filter bank of 2D cake kernels.</p> <p>Parameters:</p> Name Type Description Default <code>n_orientations</code> <code>int</code> <p>number of orientations to include in the bank</p> required <code>size</code> <code>int</code> <p>size of (square) dimension of output</p> required <code>space</code> <code>str</code> <p>output space of filters, 'real' or 'fourier'</p> required <code>spline_order</code> <code>int</code> <p>order of b-spline</p> required <code>overlap_factor</code> <code>int</code> <p>sets the amount of overlap between adjacent orientations in the bank</p> required <code>inflection_point_hf</code> <code>float</code> <p>sets the high frequency cutoff of the wavelet</p> required <code>poly_order_hf</code> <code>int</code> <p>order of high frequency filter polynomial. higher orders give a sharper rolloff</p> required <code>inflection_point_lf</code> <code>float</code> <p>sets the low frequency cutoff of the wavelet, defaults to None (no low freq. filtering)</p> required <code>poly_order_lf</code> <code>int</code> <p>order of low frequency filter polynomial. higher orders give a sharper rolloff. defaults to None, which means no low freq. filtering.</p> required <code>centered</code> <code>bool</code> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>space</code> isn't 'real' or 'fourier'</p> <p>Returns:</p> Type Description <code>Num[Array, '{n_orientations} {size} {size}'] | Tuple[Num[Array, '{n_orientations} {size} {size}'], Float[Array, ' {n_orientations}']]</code> <p>Num[Array]: [n_orientations x size x size] array of filters (1 per orientation)</p>"},{"location":"documentation/wavelet/cake/#calcite.wavelet.cake.orientation_bank_2d_real","title":"<code>calcite.wavelet.cake.orientation_bank_2d_real(n_orientations, size, spline_order, overlap_factor, inflection_point_hf, poly_order_hf, inflection_point_lf, poly_order_lf, return_angles=False)</code>","text":"<p>Create a filter bank of real-space 2D cake kernels.</p> <p>Parameters:</p> Name Type Description Default <code>n_orientations</code> <code>int</code> <p>number of orientations to include in the bank</p> required <code>size</code> <code>int</code> <p>size of (square) dimension of output</p> required <code>spline_order</code> <code>int</code> <p>order of b-spline</p> required <code>overlap_factor</code> <code>int</code> <p>sets the amount of overlap between adjacent orientations in the bank</p> required <code>inflection_point_hf</code> <code>float</code> <p>sets the high frequency cutoff of the wavelet</p> required <code>poly_order_hf</code> <code>int</code> <p>order of high frequency filter polynomial. higher orders give a sharper rolloff</p> required <code>inflection_point_lf</code> <code>float</code> <p>sets the low frequency cutoff of the wavelet</p> required <code>poly_order_lf</code> <code>int</code> <p>order of low frequency filter polynomial. higher orders give a sharper rolloff</p> required <code>return_angles</code> <code>bool</code> <p>whether to (also) return the angle at which each filter corresponds to. Defaults to False.</p> <code>False</code> <p>Returns:     Complex[Array]: [n_orientations x size x size] array of filters (1 per orientation)</p>"},{"location":"documentation/wavelet/cake/#calcite.wavelet.cake.orientation_bank_2d_fourier","title":"<code>calcite.wavelet.cake.orientation_bank_2d_fourier(n_orientations, size, spline_order, overlap_factor, inflection_point_hf, poly_order_hf, inflection_point_lf, poly_order_lf, centered=False, return_angles=False)</code>","text":"<p>Create a filter bank of fourier-space 2D cake kernels.</p> <p>Parameters:</p> Name Type Description Default <code>n_orientations</code> <code>int</code> <p>number of orientations to include in the bank</p> required <code>size</code> <code>int</code> <p>size of (square) dimension of output</p> required <code>spline_order</code> <code>int</code> <p>order of b-spline</p> required <code>overlap_factor</code> <code>int</code> <p>sets the amount of overlap between adjacent orientations in the bank</p> required <code>inflection_point_hf</code> <code>float</code> <p>sets the high frequency cutoff of the wavelet</p> required <code>poly_order_hf</code> <code>int</code> <p>order of high frequency filter polynomial. higher orders give a sharper rolloff</p> required <code>inflection_point_lf</code> <code>float</code> <p>sets the low frequency cutoff of the wavelet</p> required <code>poly_order_lf</code> <code>int</code> <p>order of low frequency filter polynomial. higher orders give a sharper rolloff</p> required <code>return_angles</code> <code>bool</code> <p>whether to (also) return the angle at which each filter corresponds to. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Real[Array, '{n_orientations} {size} {size}'] | Tuple[Real[Array, '{n_orientations} {size} {size}'], Float[Array, ' {n_orientations}']]</code> <p>Real[Array]: [n_orientations x size x size] array of filters (1 per orientation)</p>"},{"location":"documentation/wavelet/cake/#calcite.wavelet.cake.orientation_bank_3d_fourier","title":"<code>calcite.wavelet.cake.orientation_bank_3d_fourier(size, num_ori, gamma_window, nyquist_freq, sigma_erf, s_0, s_rho, big_ell, centered=False, return_angles=False, angle_fmt='spherical')</code>","text":"<p>Generate a filter bank of 3D cake wavelets.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>size of output wavelet (will be size^3)</p> required <code>num_ori</code> <code>int</code> <p>num. of orientations in the filter bank</p> required <code>gamma_window</code> <code>float</code> <p>gamma parameter for the radial window, fixes the inflection point for the rolloff at gamma*nyquist_freq</p> required <code>nyquist_freq</code> <code>float</code> <p>nyquist frequency of the data</p> required <code>sigma_erf</code> <code>float</code> <p>controls steepness of the decay around the Nyquist frequency.</p> required <code>s_0</code> <code>float</code> <p>controls tradeoff between more uniform reconstruction at the cost of less directionality.</p> required <code>s_rho</code> <code>float | None</code> required <code>big_ell</code> <code>int</code> <p>order to compute the spherical harmonics up to.</p> required <code>centered</code> <code>bool</code> <p>whether the wavelets are centered in Fourier space (as if fftshift'd). Defaults to False.</p> <code>False</code> <code>return_angles</code> <code>bool</code> <p>return angles corresponding to each wavelet in the filter bank. Defaults to False.</p> <code>False</code> <code>angle_fmt</code> <code>str</code> <p>the format to return the angles in, if <code>return_angles</code> is set to <code>True</code>. Defaults to \"spherical\".</p> <code>'spherical'</code> <p>Returns:</p> Type Description <code>Complex[Array, '{num_ori} {size} {size} {size}'] | Tuple[Complex[Array, '{num_ori} {size} {size} {size}'], Float[Array, ...]]</code> <p>Complex[Array, {num_ori} {size} {size} {size}] | Tuple[Complex[Array, {num_ori} {size} {size} {size}], Float[Array, ...]]</p>"},{"location":"documentation/wavelet/cake/#single-kernels","title":"Single Kernels","text":""},{"location":"documentation/wavelet/cake/#calcite.wavelet.cake.cake_wavelet_3d_fourier","title":"<code>calcite.wavelet.cake.cake_wavelet_3d_fourier(size, gamma_window, nyquist_freq, sigma_erf, s_0, s_rho, alpha, beta, gamma, big_ell, centered=False)</code>","text":"<p>3D cake wavelet, in the Fourier domain.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>size of output wavelet (will be size^3)</p> required <code>gamma_window</code> <code>float</code> <p>gamma parameter for the radial window, fixes the inflection point for the rolloff at <code>gamma*nyquist_freq</code>.</p> required <code>nyquist_freq</code> <code>float</code> <p>nyquist frequency of the data (same units as size)</p> required <code>sigma_erf</code> <code>float</code> <p>controls the steepness of the decay around the Nyquist frequency.</p> required <code>s_0</code> <code>float</code> <p>controls tradeoff between more uniform reconstruction at the cost of less directionality.</p> required <code>s_rho</code> <code>float</code> <p>low frequency window variance.</p> required <code>alpha</code> <code>float</code> <p>rotation around x-axis</p> required <code>beta</code> <code>float</code> <p>rotation around y-axis</p> required <code>gamma</code> <code>float</code> <p>rotation around z-axis</p> required <code>big_ell</code> <code>int</code> <p>order to compute the spherical harmonics up to. In [2], this is \"L\".</p> required <code>centered</code> <code>bool</code> <p>whether the wavelet is centered in Fourier space (as if it were <code>fftshift</code>'d). Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Complex[Array, '{size} {size} {size}']</code> <p>Complex[Array]: a single cake wavelet, in the Fourier domain.</p>"},{"location":"documentation/wavelet/cake/#utilities","title":"Utilities","text":""},{"location":"documentation/wavelet/cake/#calcite.wavelet.cake.split_cake_wavelet_fourier","title":"<code>calcite.wavelet.cake.split_cake_wavelet_fourier(wavelet, s_rho)</code>","text":"<p>Split the wavelet into high/low frequency components.</p> <p>See Sect. 2.1.1 of [2], this implements Eqns 18 with Gaussian window specified by Eqn. 19.</p> <p>Returns:</p> Type Description <code>Tuple[Complex[Array, ...], Complex[Array, ...]]</code> <p>Tuple[Complex[Array],Complex[Array]]: (low, high) frequency parts of input wavelet.</p>"},{"location":"documentation/wavelet/discrete/","title":"<code>wavelet.discrete</code>","text":"<p>Discrete Wavelets.</p> <p>Functions and utilities for handling and computing with discrete wavelets.</p> <p>Create a DiscreteWavelet object from the wavelet name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the wavelet to construct</p> required <p>Returns:</p> Type Description <code>DiscreteWavelet</code> <p>DiscreteWavelet</p> <p>handler: python options: show_source: false show_root_heading: true</p> <p>Construct a filter bank from the low-pass reconstruction filter.</p> <p>Parameters:</p> Name Type Description Default <code>rec_lo</code> <code>Float[Array, s]</code> <p>low-pass reconstruction filter, of size \"s\"</p> required <p>Returns:     Tuple[Array,Array,Array,Array]: dec_lo, dec_hi, rec_lo, rec_hi</p> <p>handler: python options: show_source: false show_root_heading: true</p>"},{"location":"documentation/wavelet/discrete/#utilites","title":"Utilites","text":"<p>Create quadrature mirror filter for input filter.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Float[Array, s]</code> <p>input filter sequence (1d)</p> required <p>Returns:     Float[Array, 's']: quadrature mirror filter of input filter</p> <p>handler: python options: show_source: false show_root_heading: true</p>"},{"location":"documentation/wavelet/gabor/","title":"<code>wavelet.gabor</code>","text":"<p>Gabor wavelets.</p> <p>Gabor wavelets are fourier modes modulated by a gaussian envelope. The gaussian envelope localizes the fourier mode in space.</p>"},{"location":"documentation/wavelet/gabor/#single-kernels","title":"Single Kernels","text":"<p>2d Gaussian kernel, generated by making a Gabor kernel with frequency=0 (so no modulation by sinusoidal plane wave).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if domain != 'real' or 'fourier'</p> <p>Returns:</p> Type Description <code>Complex[Array, '{size_h} {size_w}']</code> <p>Complex[Array]</p> <p>handler: python options: show_source: false show_root_heading: true</p> <p>Real-space kernel for 2D Gabor filter.</p> <p>Parameters:</p> Name Type Description Default <code>size_h</code> <code>int</code> <p>spatial size of filter, height, in pixels.</p> required <code>size_w</code> <code>int</code> <p>spatial size of filter, width, in pixels.</p> required <code>sigma</code> <code>float) </code> <p>bandwidth of filter (linear size of receptive field).</p> required <code>frequency</code> <code>float</code> <p>spatial frequency of the cosine factor</p> required <code>theta</code> <code>float</code> <p>angle of filter, in [0, pi]</p> required <code>gamma</code> <code>float</code> <p>ellipticity of the filter. Defaults to 1.0.</p> <code>1.0</code> <code>offset</code> <code>float</code> <p>phase offset of the cosine factor. Defaults to 0.0.</p> <code>0.0</code> <code>dtype</code> <p>datatype of output. One of <code>jnp.complex64</code> or <code>jnp.complex128</code>. Defaults to jnp.complex64.</p> <code>complex64</code> <p>Returns:</p> Type Description <code>Complex[Array, '{size_h} {size_w}']</code> <p>Complex[Array]</p> <p>handler: python options: show_source: false show_root_heading: true</p> <p>Fourier-space kernel for 2D Gabor filter.</p> <p>Parameters:</p> Name Type Description Default <code>size_h</code> <code>int</code> <p>spatial size of filter, height, in pixels.</p> required <code>size_w</code> <code>int</code> <p>spatial size of filter, width, in pixels.</p> required <code>sigma</code> <code>float) </code> <p>bandwidth of filter (linear size of receptive field).</p> required <code>frequency</code> <code>float</code> <p>spatial frequency of the cosine factor</p> required <code>theta</code> <code>float</code> <p>angle of filter, in [0, pi]</p> required <code>gamma</code> <code>float</code> <p>ellipticity of the filter. Defaults to 1.0.</p> <code>1.0</code> <code>offset</code> <code>float</code> <p>phase offset of the cosine factor. Defaults to 0.0.</p> <code>0.0</code> <code>dtype</code> <p>datatype of output. One of <code>jnp.complex64</code> or <code>jnp.complex128</code>. Defaults to jnp.complex64.</p> <code>float32</code> <p>Returns:</p> Type Description <code>Real[Array, '{size_h} {size_w}']</code> <p>Real[Array]</p> <p>handler: python options: show_source: false show_root_heading: true</p> <p>Real-space kernel for 3D Gabor filter.</p> <p>Parameters:</p> Name Type Description Default <code>size_z</code> <code>int</code> <p>spatial size of filter, depth, in pixels</p> required <code>size_h</code> <code>int</code> <p>spatial size of filter, height, in pixels.</p> required <code>size_w</code> <code>int</code> <p>spatial size of filter, width, in pixels.</p> required <code>sigma</code> <code>float) </code> <p>bandwidth of filter (linear size of receptive field).</p> required <code>frequency</code> <code>float</code> <p>spatial frequency of the cosine factor</p> required <code>theta</code> <code>float</code> <p>angle of filter, in [0, pi]</p> required <code>psi</code> <code>float</code> <p>description</p> required <code>gamma1</code> <code>float</code> <p>ellipticity of the filter. Defaults to 1.0.</p> <code>1.0</code> <code>gamma2</code> <code>float</code> <p>ellipticity of the filter. Defaults to 1.0.</p> <code>1.0</code> <code>offset</code> <code>float</code> <p>phase offset of the cosine factor. Defaults to 0.0.</p> <code>0.0</code> <code>dtype</code> <code>_type_</code> <p>datatype of output. One of <code>jnp.complex64</code> or <code>jnp.complex128</code>. Defaults to jnp.complex64.</p> <code>complex64</code> <p>Returns:</p> Type Description <code>Complex[Array, '{size_z} {size_h} {size_w}']</code> <p>Complex[Array]</p> <p>handler: python options: show_source: false show_root_heading: true</p> <p>Real-space kernel for 3D Gabor filter.</p> <p>Parameters:</p> Name Type Description Default <code>size_z</code> <code>int</code> <p>spatial size of filter, depth, in pixels</p> required <code>size_h</code> <code>int</code> <p>spatial size of filter, height, in pixels.</p> required <code>size_w</code> <code>int</code> <p>spatial size of filter, width, in pixels.</p> required <code>sigma</code> <code>float) </code> <p>bandwidth of filter (linear size of receptive field).</p> required <code>frequency</code> <code>float</code> <p>spatial frequency of the cosine factor</p> required <code>theta</code> <code>float</code> <p>angle of filter, in [0, pi]</p> required <code>psi</code> <code>float</code> <p>description</p> required <code>gamma1</code> <code>float</code> <p>ellipticity of the filter. Defaults to 1.0.</p> <code>1.0</code> <code>gamma2</code> <code>float</code> <p>ellipticity of the filter. Defaults to 1.0.</p> <code>1.0</code> <code>offset</code> <code>float</code> <p>phase offset of the cosine factor. Defaults to 0.0.</p> <code>0.0</code> <code>dtype</code> <code>_type_</code> <p>datatype of output. One of <code>jnp.complex64</code> or <code>jnp.complex128</code>. Defaults to jnp.complex64.</p> <code>float32</code> <p>Returns:</p> Type Description <code>Real[Array, '{size_z} {size_h} {size_w}']</code> <p>Complex[Array]</p> <p>handler: python options: show_source: false show_root_heading: true</p>"},{"location":"documentation/wavelet/morlet/","title":"<code>wavelet.morlet</code>","text":"<p>Morlet wavelets.</p> <p>Morlet filters are Gabor filters with a pre-modulation offset. This offset subtracts a gaussian profile centered at the original -- cancelling out the zero-frequency component and making the Gabor a bandpass filter.</p>"},{"location":"documentation/wavelet/morlet/#filter-banks","title":"Filter Banks","text":"<p>Filter bank of 2D Morlet filters.</p> <p>The resulting bank is a 5D tensor (n_scales x n_orientations x n_phases x size_h x size_w).</p> <p>Parameters:</p> Name Type Description Default <code>size_h</code> <code>int</code> <p>spatial size of filter, height. Specified in pixels.</p> required <code>size_w</code> <code>int</code> <p>Spatial size of filter, width. Specified in pixels.</p> required <code>n_scales</code> <code>int</code> <p>Number of spatial scales in the filter bank.</p> required <code>n_orientations</code> <code>int</code> <p>Number of orientations in the filter bank.</p> required <code>n_phases</code> <code>int</code> <p>Number of phases in the filter bank.</p> required <code>space</code> <code>str</code> <p>Output space of filters, one of 'real' or 'fourier'.</p> required <code>adicity</code> <code>int</code> <p>Adicity of the spatial scale separation. Defaults to 2.</p> <code>2</code> <code>sigma_prefactor</code> <code>float</code> <p>sigma = (sigma_prefactor) * adicity**scale. Defaults to 0.8.</p> <code>0.8</code> <code>freq_prefactor</code> <code>float</code> <p>freq = (freq_prefactor) / adicity*scale. Defaults to 3math.pi/4.</p> <code>3 * pi / 4</code> <code>gamma_prefactor</code> <code>float</code> <p>gamma = gamma_prefactor / n_orientations. Defaults to 4.0.</p> <code>4.0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if output space isn't one of 'real' or 'fourier'</p> <p>Returns:</p> Name Type Description <code>ndarray</code> <code>Num[Array, '{n_scales} {n_orientations} {n_phases} {size_h} {size_w}']</code> <p>real if output space is 'fourier', complex if output space is 'real'.</p> <p>handler: python options: show_source: false show_root_heading: true</p> <p>Filter bank of 2D Morlet kernels, generated via the scikit API.</p> <p>Parameters:</p> Name Type Description Default <code>n_stds</code> <code>float</code> <p>size of output kernel, in standard deviations</p> required <code>n_orientations</code> <code>int</code> required <code>scale</code> <code>int</code> <p>scale at which the filter bank will be generated. Defaults to 0.</p> <code>0</code> <code>space</code> <code>str</code> <p>space of kernels ('real' or 'fourier'). Defaults to 'real'.</p> <code>'real'</code> <code>adicity</code> <code>int</code> <p>adicity of scale separation being used. Defaults to 2.</p> <code>2</code> <code>sigma_prefactor</code> <code>float</code> <p>sigma = (sigma_prefactor) * adicity**scale. Defaults to 0.8.</p> <code>0.8</code> <code>freq_prefactor</code> <code>float</code> <p>freq = (freq_prefactor) / adicity*scale. Defaults to 3math.pi/4.</p> <code>3 * pi / 4</code> <code>gamma_prefactor</code> <code>float</code> <p>gamma = gamma_prefactor / n_orientations. Defaults to 4.0.</p> <code>4.0</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>if <code>space=='fourier'</code>. only real-space kernels implemented.</p> <p>Returns:</p> Type Description <code>Complex[Array, '{n_orientations} sze_h sze_w']</code> <p>Complex[Array]: (# orientations) x (kernel_height) x (kernel_width)</p> <p>handler: python options: show_source: false show_root_heading: true</p>"},{"location":"documentation/wavelet/morlet/#calcite.wavelet.morlet.filter_bank_2d_scikit--of-orientations-in-filter-bank","title":"of orientations in filter bank","text":""},{"location":"documentation/wavelet/morlet/#single-kernels","title":"Single Kernels","text":"<p>Real-space kernel for 2D Morlet filter.</p> <p>Parameters:</p> Name Type Description Default <code>size_h</code> <code>int</code> <p>spatial size of filter, height, in pixels.</p> required <code>size_w</code> <code>int</code> <p>spatial size of filter, width, in pixels.</p> required <code>sigma</code> <code>float) </code> <p>bandwidth of filter (linear size of receptive field).</p> required <code>frequency</code> <code>float</code> <p>spatial frequency of the cosine factor</p> required <code>theta</code> <code>float</code> <p>angle of filter, in [0, pi]</p> required <code>gamma</code> <code>float</code> <p>ellipticity of the filter. Defaults to 1.0.</p> <code>1.0</code> <code>offset</code> <code>float</code> <p>phase offset of the cosine factor. Defaults to 0.0.</p> <code>0.0</code> <code>dtype</code> <p>datatype of output. One of <code>jnp.complex64</code> or <code>jnp.complex128</code>. Defaults to jnp.complex64.</p> <code>complex64</code> <p>Returns:</p> Type Description <code>Complex[Array, '{size_h} {size_w}']</code> <p>Complex[Array]</p> <p>handler: python options: show_source: false show_root_heading: true</p> <p>Real-space kernel for 2D Morlet filter.</p> <p>Parameters:</p> Name Type Description Default <code>size_h</code> <code>int</code> <p>spatial size of filter, height, in pixels.</p> required <code>size_w</code> <code>int</code> <p>spatial size of filter, width, in pixels.</p> required <code>sigma</code> <code>float) </code> <p>bandwidth of filter (linear size of receptive field).</p> required <code>frequency</code> <code>float</code> <p>spatial frequency of the cosine factor</p> required <code>theta</code> <code>float</code> <p>angle of filter, in [0, pi]</p> required <code>gamma</code> <code>float</code> <p>ellipticity of the filter. Defaults to 1.0.</p> <code>1.0</code> <code>offset</code> <code>float</code> <p>phase offset of the cosine factor. Defaults to 0.0.</p> <code>0.0</code> <code>dtype</code> <p>datatype of output. One of <code>jnp.complex64</code> or <code>jnp.complex128</code>. Defaults to jnp.complex64.</p> <code>float32</code> <p>Returns:</p> Type Description <code>Real[Array, '{size_h} {size_w}']</code> <p>Real[Array]</p> <p>handler: python options: show_source: false show_root_heading: true</p> <p>Real-space 2D Morlet kernel, using function similar to that of scikit.</p> <p>Parameters:</p> Name Type Description Default <code>frequency</code> <code>float</code> <p>Spatial frequency of the harmonic function, in pixels.</p> required <code>theta</code> <code>float</code> <p>Orientation in radians. Defaults to 0..</p> <code>0</code> <code>bandwidth</code> <code>float</code> <p>Filter bandwidth, sets sigma_x,y. Defaults to 1..</p> <code>1.0</code> <code>sigma_x</code> <code>float | None</code> <p>Standard deviation in x-direction (pre-rotation). Defaults to None.</p> <code>None</code> <code>sigma_y</code> <code>float | None</code> <p>Standard deviation in y-direction (pre-rotation). Defaults to None.</p> <code>None</code> <code>n_stds</code> <code>float</code> <p>Size of the output kernel, in standard deviations. Defaults to 3.</p> <code>3</code> <code>offset</code> <code>float</code> <p>Phase offset of the harmonic function. Defaults to 0.</p> <code>0</code> <code>shape</code> <code>Tuple[int, int]</code> <p>Directly specify size of output kernel. Defaults to None.</p> <code>None</code> <code>dtype</code> <code>optional</code> <p>Datatype of output kernel (single or double precision). Defaults to jnp.complex128.</p> <code>complex64</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If output dtype is not complex</p> <p>Returns:</p> Type Description <code>Complex[Array, 'h w']</code> <p>Complex[Array]</p> <p>handler: python options: show_source: false show_root_heading: true</p>"},{"location":"documentation/wavelet/ricker/","title":"<code>wavelet.ricker</code>","text":"<p>Ricker Wavelets.</p> <p>Also known as Laplacian of Gaussian (LoG), \"Mexican hat\", or Marr wavelets. The ricker wavelet is the negative normalized 2nd derivative of a Gaussian function.</p>"},{"location":"documentation/wavelet/ricker/#references","title":"References","text":"<p>[1] Sage, et al. \"Automatic Tracking of Individual Fluorescence Particles: Application to the Study of Chromosome Dynamics\" IEEE Transactions on Image Processing, vol. 14, no. 9, pp. 1372-1383, September 2005.</p>"},{"location":"documentation/wavelet/ricker/#single-kernels","title":"Single Kernels","text":""},{"location":"documentation/wavelet/ricker/#calcite.wavelet.ricker.ricker_kernel_1d_real","title":"<code>calcite.wavelet.ricker.ricker_kernel_1d_real(length, sigma)</code>","text":"<p>One dimensional Ricker kernel.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>length of the filter.</p> required <code>sigma</code> <code>float</code> <p>standard deviation.</p> required <p>Returns:</p> Type Description <code>Float[Array, ' {length}']</code> <p>Float[Array, \"{length}\"]: the 1D kernel</p>"},{"location":"documentation/wavelet/ricker/#calcite.wavelet.ricker.ricker_kernel_2d_real","title":"<code>calcite.wavelet.ricker.ricker_kernel_2d_real(size_h, size_w, sigma_x, sigma_y)</code>","text":"<p>Generate a real-space 2D Ricker kernel.</p> <p>Parameters:</p> Name Type Description Default <code>size_h</code> <code>int</code> <p>size of the filter, # rows</p> required <code>size_w</code> <code>int</code> <p>size of the filter, # cols</p> required <code>sigma_x</code> <code>float</code> <p>standard deviation in the x-direction (cols)</p> required <code>sigma_y</code> <code>float</code> <p>standard deviation in the y-direction (rows)</p> required <p>Returns:</p> Type Description <code>Float[Array, '{size_h} {size_w}']</code> <p>Float[Array, \"{size_h} {size_w}\"]</p>"},{"location":"documentation/wavelet/ricker/#calcite.wavelet.ricker.ricker_kernel_3d_real","title":"<code>calcite.wavelet.ricker.ricker_kernel_3d_real(size_z, size_h, size_w, sigma_x, sigma_y, sigma_z)</code>","text":"<p>Generate a real-space 3D Ricker kernel.</p> <p>Formula is taken from [1].</p> <p>Parameters:</p> Name Type Description Default <code>size_z</code> <code>int</code> <p>size of the filter in depth</p> required <code>size_h</code> <code>int</code> <p>size of the filter, # rows</p> required <code>size_w</code> <code>int</code> <p>size of the filter, # cols</p> required <code>sigma_x</code> <code>float</code> <p>standard deviation in the x-direction (cols)</p> required <code>sigma_y</code> <code>float</code> <p>standard deviation in the y-direction (rows)</p> required <code>sigma_z</code> <code>float</code> <p>standard deviation in the z-direction (depth)</p> required <p>Returns:</p> Type Description <code>Float[Array, '{size_z} {size_h} {size_w}']</code> <p>Float[Array, \"{size_z} {size_h} {size_w}\"]</p>"},{"location":"documentation/wavelet/ricker/#calcite.wavelet.ricker.ricker_kernel_2d_fourier","title":"<code>calcite.wavelet.ricker.ricker_kernel_2d_fourier(size_h, size_w, sigma_x, sigma_y)</code>","text":"<p>Generate a fourier-space 2D Ricker kernel.</p> <p>Parameters:</p> Name Type Description Default <code>size_h</code> <code>int</code> <p>size of the filter, # rows</p> required <code>size_w</code> <code>int</code> <p>size of the filter, # cols</p> required <code>sigma_x</code> <code>float</code> <p>standard deviation in the x-direction (cols)</p> required <code>sigma_y</code> <code>float</code> <p>standard deviation in the y-direction (rows)</p> required <p>Returns:</p> Type Description <code>Complex[Array, '{size_h} {size_w}']</code> <p>Complex[Array, \"{size_h} {size_w}\"]</p>"},{"location":"documentation/wavelet/solid/","title":"<code>wavelet.solid</code>","text":"<p>Solid Harmonic Wavelets.</p> <p>First introduced in [1]: \"Solid harmonics are solutions of the Laplace equation, $\\Delta{}f=0$.\" Wavelets are obtained by localizing the support of a solid harmonic in space by multiplication with a Gaussian.</p> <p>In 2D: $\\psi_\\ell(r,\\phi) = In 3D: TODO</p>"},{"location":"documentation/wavelet/solid/#references","title":"References","text":"<p>[1] Eickenberg, Michael, et al. \"Solid harmonic wavelet scattering: Predicting quantum molecular energy from invariant descriptors of 3D electronic densities.\" Advances in Neural Information Processing Systems 30 (2017). [2] Eickenberg, Michael, et al. \"Solid harmonic wavelet scattering for predictions of molecule properties.\" The Journal of chemical physics 148.24 (2018).</p>"},{"location":"documentation/wavelet/solid/#single-kernels","title":"Single Kernels","text":"<p>2d solid harmonic wavelet filter.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>size of one dimension of (square) filter</p> required <code>space</code> <code>str</code> <p>'real' or 'fourier', space of filter</p> required <code>ell</code> <code>int</code> <p>polynomial order</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if space != 'real' or 'fourier'</p> <p>Returns:</p> Type Description <code>Float[Array, ' {size} {size}']</code> <p>Float[Array]</p> <p>handler: python options: show_source: false show_root_heading: true</p>"},{"location":"documentation/wavelet/solid/#utilities","title":"Utilities","text":"<p>2D solid harmonic wavelet value.</p> <p>Parameters:</p> Name Type Description Default <code>ell</code> <code>float</code> <p>polynomial order</p> required <code>r</code> <code>float</code> <p>radial coordinate of polar coordinates</p> required <code>psi</code> <code>float</code> <p>angular coordinate of polar coordinates</p> required <p>Returns:</p> Type Description <code>Array</code> <p>float</p> <p>handler: python options: show_source: false show_root_heading: true</p> <p>Fourier space 2D solid harmonic wavelet value.</p> <p>Parameters:</p> Name Type Description Default <code>ell</code> <code>int</code> <p>polynomial order</p> required <code>_lambda</code> <code>float</code> <p>frequency</p> required <code>alpha</code> <code>float</code> <p>angle</p> required <p>Returns:</p> Type Description <code>Array</code> <p>float</p> <p>handler: python options: show_source: false show_root_heading: true</p> <p>Real space 3D solid harmonic wavelet value.</p> <p>Parameters:</p> Name Type Description Default <code>ell</code> <code>int</code> <p>degree of spherical harmonic</p> required <code>m</code> <code>int</code> <p>order of spherical harmonic</p> required <code>r</code> <code>float</code> <p>radius</p> required <code>theta</code> <code>float</code> <p>azimuthal angle</p> required <code>psi</code> <code>float</code> <p>elevation angle</p> required <p>Returns:</p> Type Description <code>Array</code> <p>float</p> <p>handler: python options: show_source: false show_root_heading: true</p> <p>Fourier space 3D solid harmonic wavelet value.</p> <p>Parameters:</p> Name Type Description Default <code>ell</code> <code>int</code> <p>degree of spherical harmonic</p> required <code>m</code> <code>int</code> <p>order of spherical harmonic</p> required <code>_lambda</code> <code>float</code> <p>wavelength</p> required <code>alpha</code> <code>float</code> <p>azimuthal angle</p> required <code>beta</code> <code>float</code> <p>elevation angle</p> required <p>Returns:</p> Type Description <code>Array</code> <p>float</p> <p>handler: python options: show_source: false show_root_heading: true</p>"},{"location":"documentation/wavelet/triglet/","title":"<code>wavelet.triglet</code>","text":"<p>Triglet wavelets.</p> <p>Introduced in [1].</p>"},{"location":"documentation/wavelet/triglet/#references","title":"References","text":"<p>[1] Saydjari, Andrew K., and Douglas P. Finkbeiner. \"Equivariant wavelets: Fast rotation and translation invariant wavelet scattering transforms.\" IEEE Transactions on Pattern Analysis and Machine Intelligence 45.2 (2022): 1716-1731.</p>"},{"location":"documentation/wavelet/triglet/#filter-banks","title":"Filter Banks","text":""},{"location":"documentation/wavelet/triglet/#calcite.wavelet.triglet.filter_bank_2d","title":"<code>calcite.wavelet.triglet.filter_bank_2d(size, j_im, ell, w=2, t=1)</code>","text":"<p>Triglet filter bank.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>size of filter in single dimension (output will be size x size)</p> required <code>j_im</code> <code>int</code> <p>log_2(size of one dimension of image)</p> required <code>ell</code> <code>int</code> <p>number of angular bins</p> required <code>w</code> <code>int</code> <p>angular width in multiples of pi/ell.</p> <code>2</code> <code>t</code> <code>int</code> <p>whether to subdivide Fourier half (t=1) or full (t=2) plane.</p> <code>1</code> <p>Returns:</p> Type Description <code>Float[Array, ' {j_im-2} {ell} {size} {size}']</code> <p>Float[Array]</p>"},{"location":"documentation/wavelet/triglet/#calcite.wavelet.triglet.filter_bank_2d_fixed_scale","title":"<code>calcite.wavelet.triglet.filter_bank_2d_fixed_scale(size, j_im, ell, j, w=2, t=1)</code>","text":"<p>Triglet filter bank at fixed scale, <code>j</code>.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>size of filter in single dimension (output will be size x size)</p> required <code>j_im</code> <code>int</code> <p>log_2(size of one dimension of image)</p> required <code>ell</code> <code>int</code> <p>number of angular bins</p> required <code>j</code> <code>int</code> <p>radial bin index</p> required <code>w</code> <code>int</code> <p>angular width in multiples of pi/ell.</p> <code>2</code> <code>t</code> <code>int</code> <p>whether to subdivide Fourier half (t=1) or full (t=2) plane.</p> <code>1</code> <p>Returns:</p> Type Description <code>Float[Array, ' {ell} {size} {size}']</code> <p>Float[Array]</p>"},{"location":"documentation/wavelet/triglet/#single-kernels","title":"Single Kernels","text":""},{"location":"documentation/wavelet/triglet/#calcite.wavelet.triglet.triglet_2d","title":"<code>calcite.wavelet.triglet.triglet_2d(size, j, a_bin, j_im, ell, w=2, t=1)</code>","text":"<p>2D triglet filter.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>size of filter in single dimension (output will be size x size)</p> required <code>j</code> <code>int</code> <p>radial bin index</p> required <code>a_bin</code> <code>int</code> <p>angular bin index</p> required <code>j_im</code> <code>int</code> <p>log_2(size of one dimension of image)</p> required <code>ell</code> <code>int</code> <p>number of angular bins</p> required <code>w</code> <code>int</code> <p>angular width in multiples of pi/ell.</p> <code>2</code> <code>t</code> <code>int</code> <p>whether to subdivide Fourier half (t=1) or full (t=2) plane.</p> <code>1</code> <p>Returns:</p> Type Description <code>Float[Array, ' {size} {size}']</code> <p>Float[Array]</p>"},{"location":"documentation/wavelet/triglet/#utilities","title":"Utilities","text":""},{"location":"documentation/wavelet/triglet/#calcite.wavelet.triglet.psihat_jl","title":"<code>calcite.wavelet.triglet.psihat_jl(r, theta, j, l, j_im, ell, w=2, t=1)</code>","text":"<p>Value of triglet at (r, \\theta).</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>float</code> <p>Fourier-space radial coordinate</p> required <code>theta</code> <code>float</code> <p>Fourier-space angular coordinate</p> required <code>j</code> <code>int</code> <p>radial bin index</p> required <code>l</code> <code>int</code> <p>angular bin index</p> required <code>j_im</code> <code>int</code> <p>log_2(size of one dimension of image)</p> required <code>ell</code> <code>int</code> <p>number of angular bins</p> required <code>w</code> <code>int</code> <p>angular width in multiples of pi/ell.</p> <code>2</code> <code>t</code> <code>int</code> <p>whether to subdivide Fourier half (t=1) or full (t=2) plane.</p> <code>1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if t doesn't equal 1 or 2.</p> <p>Returns:</p> Type Description <code>Array</code> <p>float</p>"}]}